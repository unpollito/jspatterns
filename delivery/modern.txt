As was previously indicated, we distinguish between two types of patterns: those which try to mimic that of object-oriented design, and the ones that intend to make full use of JavaScript's abilities, which we call "modern". In all these patterns, we simply try to create an object from one or several parent objects.

One of the most relevant and commonly used patterns is called prototypal inheritance. In a nutshell, it basically sets an object's prototype to be another object. This is typically achieved by having an object() function, such that the first parameter to this function is the object we want to inherit from; the function would then return a new object.

A particularly interesting feature of this pattern is that it allows us to decide whether to inherit an object's own properties or simply the reusable methods set in the prototype. This distinction matters because sometimes an object's own properties might be reusable, whereas in other cases they will be bound to a certain object. While invoking object() with an existing object inherits own properties, using that object's prototype as the argument to object() allows us only to inherit attributes defined in the prototype.

Lastly, we would simply point out that an Object.create() function is present in ECMAScript 5, which works in most current browsers save for IE 8 and older. This function takes an optional second parameter which allows us to specify parameters for the new object.

Another well-known pattern is called mix-ins, which allows for multiple inheritance. The basic idea behind it is that an object can inherit from several other objects simply by copying all of its attributes. A basic implementation should be straightforward, although caution should be taken to ensure that composite objects are copied recursively.

Rather than inheritance, the next pattern focuses on pure code reuse. If for some reason we had a method in an object which we don't want to define for a second object, it is possible to use JavaScript's call() or apply() methods. The main issue with this approach would typically be the "this" context, which if calling a function normally, would always point to the object which contains that function. However, call() and apply() take a first argument which allows us to define the "this" context that should be used when invoking this function. Therefore, this allows us to actually use a function in a different object to that where it was defined.

Care should be taken when using this approach without call() or apply(): failing to set the context appropriately will often lead to errors which are hard to spot. For instance, copying a reference to a function and passing it as a callback will not be enough to change the context. Fortunately, it is possible to define a bind() function which takes an object and a function and returns a new function which is identical to invoking the original function with the specified object as its context. A Function.prototype.bind() method is available in ECMAScript 5, although again it does not work in IE versions older than 9.

Lastly, one particularly interesting pattern is the functional pattern. While the main idea is rather similar to traditional inheritance in object-oriented languages, there are several details that make it stand out.

In the functional pattern, each object type has a constructor that takes one "spec" object which contains a list of variables needed to initialize the object. Optionally, it might also take a "my" object, which contains private variables that might be needed by a constructor up above in the inheritance chain but not necessarily in the current constructor. Then all the needed private variables will be defined and a new object ("that") is created. "that" will contain all the necessary methods, such as getters and setters, but it will not have any exposed variables. Inheritance is achieved by initializing "that" to an object of another type by invoking that type's constructor; if we don't want to inherit, we can simply initialize "that" to an empty object.

The functional pattern is significantly less verbose than other approaches, enforces attribute and method privacy easily and allows to do without "new" or "this", keywords whose inappropriate use often cause hard-to-spot errors. However, it has the downside that object instantiation is usually slower, as all the methods inside the returned object need to be defined with each call to the constructor. This needs to be taken into account when deciding which pattern to use; if lots of objects are to be created, then this might not be the most appropriate approach.

To finish, we would like to indicate that, as a whole, classic inheritance is a powerful tool, but not necessarily the most appropriate one for JavaScript. Many static, strongly typed languages lack JS' abilities, which means that there are many simpler ways to achieve the same purpose.

We have chosen to refactor XDate, a library which aims to extend the native JavaScript Date type. This library adds several new operations, such as adding a set amount of years, months, etc. to a date, as well as calculating the difference between two dates. The source files for this project can be found in https://github.com/arshaw/xdate.

The main issue we have found with this library is that, instead of extending from a native Date object, it is simply storing one internally and manually defining all the operations, which leads to unnecessary code clutter; in particular, all getters or setters must be manually defined. While extending a Date object is not straightforward (see https://stackoverflow.com/questions/6075231/how-to-extend-the-javascript-date-object), some of the previously used patterns can be used to significantly reduce the amount of written code. In particular, we have used the functional pattern.

It needs to be said that, due to the considerable size of the XDate library and the costs of refactoring its constructor, the refactored version of the project does not contain all the operations; instead, it contains a subset of these, which we believe are sufficient to illustrate the differences between both approaches.

Extending directly from Date using the functional pattern allowed us to get rid, at the very least, of the definition of all "getUTC" methods. The getters in the refactored version do not work exactly as those in the original project, as we do not observe whether the object is set to UTC, but even if we were to mimic this behaviour, the amount of written code would still be significantly less; we'd only have to call either a get or getUTC function depending on the UTC mode. Something similar happens to the setters, which we have implemented; while the setters' basic functionality is untouched, the ones in XDate return an instance of the object, which can be used for chaining. Although this lead us to implementing manually all setters as well, the amount of code used is again smaller and could have been avoided completely had we decided not to allow chaining.

All in all, it seems clear that the functional pattern allows for much cleaner code. However, it should also be stressed that refactoring a large class' constructor can take a very significant amount of time; on top of that, this particular case also involves modifying public APIs, which can be inappropriate for a reusable library. In particular, our changes involve dropping the need to use the "new" keyword and, most importantly, renaming the constructor from XDate to xDate, so as to indicate that the constructor doesn't need to be invoked with "new".